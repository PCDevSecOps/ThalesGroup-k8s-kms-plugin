{
  "swagger": "2.0",
  "info": {
    "title": "apis/kms/v1/service.proto",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/decrypt": {
      "post": {
        "summary": "Decrypts data that was protected by [Encrypt][thalescpl.io.istio.v1.KeyManagementService.Encrypt]. The [CryptoKey.purpose][thalescpl.io.istio.v1.CryptoKey.purpose]\nmust be [ENCRYPT_DECRYPT][thalescpl.io.istio.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].",
        "operationId": "KeyManagementService_Decrypt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DecryptResponse"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1DecryptRequest"
            }
          }
        ],
        "tags": [
          "KeyManagementService"
        ]
      }
    },
    "/v1/encrypt": {
      "post": {
        "summary": "Encrypts data, so that it can only be recovered by a call to [Decrypt][thalescpl.io.istio.v1.KeyManagementService.Decrypt].\nThe [CryptoKey.purpose][thalescpl.io.istio.v1.CryptoKey.purpose] must be\n[ENCRYPT_DECRYPT][thalescpl.io.istio.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].",
        "operationId": "KeyManagementService_Encrypt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1EncryptResponse"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1EncryptRequest"
            }
          }
        ],
        "tags": [
          "KeyManagementService"
        ]
      }
    },
    "/v1/keys": {
      "post": {
        "summary": "Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a [KeyRing][google.cloud.kms.v1.KeyRing].",
        "description": "[CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and\n[CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]\nare required.",
        "operationId": "KeyManagementService_CreateCryptoKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CryptoKey"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field values.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CryptoKey"
            }
          }
        ],
        "tags": [
          "KeyManagementService"
        ]
      }
    },
    "/v1/public": {
      "get": {
        "summary": "Returns the public key for the k8s-kms-plugin's built in CA",
        "operationId": "KeyManagementService_GetPublicKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PublicKey"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "include_bundle",
            "description": "Optional. If set to true, a full truststore will be returned, not just the current CA Cert Chain.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "KeyManagementService"
        ]
      }
    },
    "/v1/sign": {
      "post": {
        "operationId": "KeyManagementService_SignCSR",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignCSRResponse"
            }
          },
          "default": {
            "description": "An unexpected error response",
            "schema": {
              "$ref": "#/definitions/runtimeError"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SignCSRRequest"
            }
          }
        ],
        "tags": [
          "KeyManagementService"
        ]
      }
    }
  },
  "definitions": {
    "CryptoKeyCryptoKeyPurpose": {
      "type": "string",
      "enum": [
        "CRYPTO_KEY_PURPOSE_UNSPECIFIED",
        "ENCRYPT_DECRYPT",
        "ASYMMETRIC_SIGN",
        "ASYMMETRIC_DECRYPT"
      ],
      "default": "CRYPTO_KEY_PURPOSE_UNSPECIFIED",
      "description": "[CryptoKeyPurpose][thalescpl.io.kms.v1.CryptoKey.CryptoKeyPurpose] describes the cryptographic capabilities of a\n[CryptoKey][thalescpl.io.kms.v1.CryptoKey]. A given key can only be used for the operations allowed by\nits purpose.\n\n - CRYPTO_KEY_PURPOSE_UNSPECIFIED: Not specified.\n - ENCRYPT_DECRYPT: [CryptoKeys][thalescpl.io.kms.v1.CryptoKey] with this purpose may be used with\n[Encrypt][thalescpl.io.kms.v1.KeyManagementService.Encrypt] and\n[Decrypt][thalescpl.io.kms.v1.KeyManagementService.Decrypt].\n - ASYMMETRIC_SIGN: [CryptoKeys][thalescpl.io.kms.v1.CryptoKey] with this purpose may be used with\n[AsymmetricSign][thalescpl.io.kms.v1.KeyManagementService.AsymmetricSign] and\n[GetPublicKey][thalescpl.io.kms.v1.KeyManagementService.GetPublicKey].\n - ASYMMETRIC_DECRYPT: [CryptoKeys][thalescpl.io.kms.v1.CryptoKey] with this purpose may be used with\n[AsymmetricDecrypt][thalescpl.io.kms.v1.KeyManagementService.AsymmetricDecrypt] and\n[GetPublicKey][thalescpl.io.kms.v1.KeyManagementService.GetPublicKey]."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "runtimeError": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1CryptoKey": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "The resource name for this [CryptoKey][thalescpl.io.kms.v1.CryptoKey]\nShould be unique to the device, and will fail if an existing key has been created by that name in the KMS"
        },
        "purpose": {
          "$ref": "#/definitions/CryptoKeyCryptoKeyPurpose",
          "description": "Immutable. The immutable purpose of this [CryptoKey][thalescpl.io.kms.v1.CryptoKey]."
        },
        "create_time": {
          "type": "string",
          "format": "date-time",
          "description": "Output only. The time at which this [CryptoKey][thalescpl.io.kms.v1.CryptoKey] was created.",
          "readOnly": true
        }
      },
      "description": "A [CryptoKey][thalescpl.io.kms.v1.CryptoKey] represents a logical key that can be used for cryptographic\noperations.\n\nA [CryptoKey][thalescpl.io.kms.v1.CryptoKey] is made up of zero or more [versions][thalescpl.io.kms.v1.CryptoKeyVersion],\nwhich represent the actual key material used in cryptographic operations."
    },
    "v1CryptoKeyAlgorithm": {
      "type": "string",
      "enum": [
        "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED",
        "GOOGLE_SYMMETRIC_ENCRYPTION",
        "RSA_SIGN_PSS_2048_SHA256",
        "RSA_SIGN_PSS_3072_SHA256",
        "RSA_SIGN_PSS_4096_SHA256",
        "RSA_SIGN_PSS_4096_SHA512",
        "RSA_SIGN_PKCS1_2048_SHA256",
        "RSA_SIGN_PKCS1_3072_SHA256",
        "RSA_SIGN_PKCS1_4096_SHA256",
        "RSA_SIGN_PKCS1_4096_SHA512",
        "RSA_DECRYPT_OAEP_2048_SHA256",
        "RSA_DECRYPT_OAEP_3072_SHA256",
        "RSA_DECRYPT_OAEP_4096_SHA256",
        "RSA_DECRYPT_OAEP_4096_SHA512",
        "EC_SIGN_P256_SHA256",
        "EC_SIGN_P384_SHA384",
        "EXTERNAL_SYMMETRIC_ENCRYPTION"
      ],
      "default": "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED",
      "description": " - CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED: Not specified.\n - GOOGLE_SYMMETRIC_ENCRYPTION: Creates symmetric encryption keys.\n - RSA_SIGN_PSS_2048_SHA256: RSASSA-PSS 2048 bit key with a SHA256 digest.\n - RSA_SIGN_PSS_3072_SHA256: RSASSA-PSS 3072 bit key with a SHA256 digest.\n - RSA_SIGN_PSS_4096_SHA256: RSASSA-PSS 4096 bit key with a SHA256 digest.\n - RSA_SIGN_PSS_4096_SHA512: RSASSA-PSS 4096 bit key with a SHA512 digest.\n - RSA_SIGN_PKCS1_2048_SHA256: RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.\n - RSA_SIGN_PKCS1_3072_SHA256: RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.\n - RSA_SIGN_PKCS1_4096_SHA256: RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.\n - RSA_SIGN_PKCS1_4096_SHA512: RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.\n - RSA_DECRYPT_OAEP_2048_SHA256: RSAES-OAEP 2048 bit key with a SHA256 digest.\n - RSA_DECRYPT_OAEP_3072_SHA256: RSAES-OAEP 3072 bit key with a SHA256 digest.\n - RSA_DECRYPT_OAEP_4096_SHA256: RSAES-OAEP 4096 bit key with a SHA256 digest.\n - RSA_DECRYPT_OAEP_4096_SHA512: RSAES-OAEP 4096 bit key with a SHA512 digest.\n - EC_SIGN_P256_SHA256: ECDSA on the NIST P-256 curve with a SHA256 digest.\n - EC_SIGN_P384_SHA384: ECDSA on the NIST P-384 curve with a SHA384 digest.\n - EXTERNAL_SYMMETRIC_ENCRYPTION: Algorithm representing symmetric encryption by an external key manager."
    },
    "v1DecryptRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Required. The resource name of the [CryptoKey][thalescpl.io.kms.v1.CryptoKey] to use for decryption.\nThe server will choose the appropriate version."
        },
        "ciphertext": {
          "type": "string",
          "format": "byte",
          "description": "Required. The encrypted data originally returned in\n[EncryptResponse.ciphertext][thalescpl.io.kms.v1.EncryptResponse.ciphertext]."
        },
        "additional_authenticated_data": {
          "type": "string",
          "format": "byte",
          "description": "Optional. Optional data that must match the data originally supplied in\n[EncryptRequest.additional_authenticated_data][thalescpl.io.kms.v1.EncryptRequest.additional_authenticated_data]."
        }
      },
      "description": "Request message for [KeyManagementService.Decrypt][thalescpl.io.kms.v1.KeyManagementService.Decrypt]."
    },
    "v1DecryptResponse": {
      "type": "object",
      "properties": {
        "plaintext": {
          "type": "string",
          "format": "byte",
          "description": "The decrypted data originally supplied in [EncryptRequest.plaintext][thalescpl.io.kms.v1.EncryptRequest.plaintext]."
        }
      },
      "description": "Response message for [KeyManagementService.Decrypt][thalescpl.io.kms.v1.KeyManagementService.Decrypt]."
    },
    "v1EncryptRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "plaintext": {
          "type": "string",
          "format": "byte",
          "description": "Required. The data to encrypt. Must be no larger than 64KiB.\n\nThe maximum size depends on the key version's"
        },
        "additional_authenticated_data": {
          "type": "string",
          "format": "byte",
          "description": "Optional. Optional data that, if specified, must also be provided during decryption\nthrough [DecryptRequest.additional_authenticated_data][thalescpl.io.kms.v1.DecryptRequest.additional_authenticated_data].\n\nThe maximum size depends on the key version's\nNOTE: he combined length of the\nplaintext and additional_authenticated_data fields must be no larger than\n8KiB."
        }
      },
      "description": "Request message for [KeyManagementService.Encrypt][thalescpl.io.kms.v1.KeyManagementService.Encrypt]."
    },
    "v1EncryptResponse": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The resource name of the [CryptoKey][thalescpl.io.kms.v1.CryptoKey] used in encryption. Check\nthis field to verify that the intended resource was used for encryption."
        },
        "ciphertext": {
          "type": "string",
          "format": "byte",
          "description": "The encrypted data."
        }
      },
      "description": "Response message for [KeyManagementService.Encrypt][thalescpl.io.kms.v1.KeyManagementService.Encrypt]."
    },
    "v1PublicKey": {
      "type": "object",
      "properties": {
        "pem": {
          "type": "string",
          "description": "The public key, encoded in PEM format. For more information, see the\n[RFC 7468](https://tools.ietf.org/html/rfc7468) sections for\n[General Considerations](https://tools.ietf.org/html/rfc7468#section-2) and\n[Textual Encoding of Subject Public Key Info]\n(https://tools.ietf.org/html/rfc7468#section-13)."
        },
        "algorithm": {
          "$ref": "#/definitions/v1CryptoKeyAlgorithm",
          "description": "The [Algorithm][thalescpl.io.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm] associated\nwith this key."
        }
      },
      "description": "The public key for a given [CryptoKey][thalescpl.io.kms.v1.CryptoKey]. Obtained via\n[GetPublicKey][thalescpl.io.kms.v1.KeyManagementService.GetPublicKey]."
    },
    "v1SignCSRRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Required. The resource name of the [CryptoKeyVersion][thalescpl.io.kms.v1.CryptoKey] to use for signing."
        },
        "csr": {
          "type": "string",
          "format": "byte",
          "description": "Required. The Certificate Signing Request\n[SignCSRRequest.csr][thalescpl.io.kms.v1.SignCSRRequest.csr]."
        }
      },
      "description": "Request message for [KeyManagementService.SignCSRRequest][thalescpl.io.kms.v1.KeyManagementService.SignCSRRequest]."
    },
    "v1SignCSRResponse": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The resource name of the [CryptoKey][thalescpl.io.kms.v1.CryptoKey] used for the signing. Check\nthis field to verify that the intended resource was used for signing."
        },
        "certificate": {
          "type": "string",
          "format": "byte",
          "description": "Required. The signed  Certificate Signing Request\n[SignCSRResponse.certificate][thalescpl.io.kms.v1.SignCSRResponse.cert]."
        }
      },
      "description": "Request message for [KeyManagementService.SignCSRResponse][thalescpl.io.kms.v1.KeyManagementService.SignCSRResponse]."
    }
  }
}
